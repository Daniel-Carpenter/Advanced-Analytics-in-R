---
title: "Homework 4 - Data Wrangling in R"
author: "Daniel Carpenter & NAME HERE"
date: "September 2022"
format: 
  pdf:
    toc: true
    toc-depth: 2
    # number-sections: true
    highlight-style: github #arrow
    code-block-border-left: "#D6D6D6"
  gfm:
    toc: true
    toc-depth: 1
    
execution:
  echo:    true
  include: true
  cache:   true
  message: false
  warning: false

editor: visual

fig-width:  7
fig-height: 3.5
---

\newpage

## Packages

```{r, message=FALSE}
library(tidyverse)

library(car)      # symbox 
library(EnvStats) # boxcox function
```

# `1` - Data Quality Report

## `1 (a)` - Read data

```{r}
# Read data
housingData <- read_csv('housingData.csv')

# create three new variables
housingData <- housingData %>%
  dplyr::mutate(age             = YrSold - YearBuilt,
                ageSinceRemodel = YrSold - YearRemodAdd,
                ageofGarage     = YrSold - GarageYrBlt
                )
```


## `1 (b)` - Numeric Housing Tibble
* Create a tibble named `housingNumeric` which contains all of the numeric variables from the original data. 

* use the `dplyr::select` command along with the `is.numeric` function to complete this task.

```{r}
# Convert df to a tibble
housingNumeric <- as_tibble(housingData) %>%
  
  # Only select numeric data 
  # note would usually use command select_if(is.numeric)
  select(where(is.numeric))
```


## `1 (c)` - Factor Housing Tibble
* create a tibble named `housingFactor` which contains all of the character variables from the original data. 

```{r}
housingFactor <- as_tibble(housingData) %>%
  
  # Change all character variables to factors
  # Keep only the changed data. Implicitly keeping only factor (prev. char vars)
  transmute_if(is.character, as.factor) 
```


## `1 (d)` - Use Glimpse

```{r}
# NOT RUN
# glimpse(housingNumeric)
# glimpse(housingFactor)
```


## `1 (e)` - Get Q1 and Q3
* create our own user-defined functions for extracting only first and 3rd quantile

* Explanation: Gets the quantiles of a vector using quantile function, but we use the `[]` brackets to retrieve the 2nd or 4th objects in the vector, which are `Q1` and `Q3`

```{r}
Q1 <- function(x,na.rm=TRUE) {
  quantile(x,na.rm=na.rm)[2]
}
Q3 <- function(x,na.rm=TRUE) {
  quantile(x,na.rm=na.rm)[4]
}
```


## `1 (f)` - Vectorized Summary Stats
* Function that will help apply several summary statistics to our data all at once

* Contains vector of functions with default to not evaluate if `na`

```{r}

# Vector of functions
myNumericSummary <- function(x){
  c(length(x), n_distinct(x), sum(is.na(x)), mean(x, na.rm=TRUE),
  min(x,na.rm=TRUE), Q1(x,na.rm=TRUE), median(x,na.rm=TRUE), Q3(x,na.rm=TRUE),
  max(x,na.rm=TRUE), sd(x,na.rm=TRUE))
}

# Name of each functions within the vector
statNames <- c('n', 'unique', 'missing', 'mean', 'min', 'Q1', 'median', 'Q3', 'max', 'sd')
```


## `1 (g)` - Apply Summary Stats
* Apply summary stats function with `summarize` function

```{r}
numericSummary <- housingNumeric %>%
  
  # Apply vector of functions using summarise
  summarise( across( where(is.numeric), ~myNumericSummary(.x) ) )
```


## `1 (h)` - Add Stats Names
* Combine original data set and the names of each summary statistic

```{r}
numericSummary <- cbind(
  stat=c("n","unique","missing","mean","min","Q1","median","Q3","max","sd"),
  numericSummary
)

# glimpse(numericSummary) # uncomment to see effects
```

\newpage

## `1 (i)` - Pretty up data

### Transform data to make it ready for output format

```{r}
numericSummaryFinal <- numericSummary %>%
  pivot_longer("Id":"ageofGarage", names_to = "variable", values_to = "value") %>%
  pivot_wider(names_from = stat, values_from = value) %>%
  mutate(missing_pct = 100*missing/n,
         unique_pct = 100*unique/n) %>%
  select(variable, n, missing, missing_pct, unique, unique_pct, everything())
```

### Show the output
```{r}
library(knitr)
options(digits=3)
options(scipen=99)
numericSummaryFinal %>% kable()
```


\newpage

## `1 (j)` - Factor Data Report


```{r}
# TODO
```


\newpage


# `2` - Transformation


## `2 (a)` - Fixing Skewed Data

### Function to Convert Skewed Data to Normally Distributed Vector
```{r}
normalizeDist <- function(aVector) {
  
  # Get the optimal lambda. Used later for converting to normal distribution
  normLambda = boxcox(aVector, optimize = TRUE)$lambda

  # Now convert vector to normal distribution, using the optimal lambda
  normalizedVector <- (aVector ** normLambda - 1) / normLambda
  
  return(normalizedVector)
}

# Colors
goodCol = 'darkseagreen3'
badCol  = 'tomato3'
```


### `i.` Fix `LotArea` in Housing Data Set

#### Lot area is highly skewed

```{r}
varTitle = 'Lot Size (Sq. Ft.)'

# See that LotArea is highly skewed
hist(housingData$LotArea, 
      main = varTitle, xlab = varTitle, col = badCol)

# Look at the symbox to see where optimal may lie
symbox(housingData$LotArea, data=housingData, powers=c(3,2,1,0,-0.5,-1,-2),
       ylab = varTitle)

# Normalize the data and store in data
housingData <- housingData %>% 
  mutate(normLotArea = normalizeDist(housingData$LotArea) )
```

#### See the normalized Lot Area variable 
* You can see that the data is definitely more normal

* However, much of the data is near the median, which may or may not be fine, depending on the analysis

```{r, fig.width=6, fig.height=6}
# Now see the results of the normalization
par(mfrow=c(2,1))

hist( housingData$LotArea, 
      main = paste('Raw', varTitle), xlab = paste('Raw', varTitle), 
      col = badCol )

hist( housingData$normLotArea,
      main = paste('Normalized', varTitle), xlab = paste('Normalized', varTitle), 
      col = goodCol)

```


\newpage

### `i.` Fix `GrLivArea` in Housing Data Set

#### Above Ground Living Area is highly skewed

```{r, fig.height=4}
varTitle = 'Above Ground Living Area (Sq. Ft.)'

# See that LotArea is highly skewed
hist(housingData$GrLivArea, 
      main = varTitle, xlab = varTitle, col = badCol )

# Look at the symbox to see where optimal may lie
symbox(housingData$GrLivArea, data=housingData, powers=c(3,2,1,0,-0.5,-1,-2),
       ylab = varTitle)

# Normalize the data and store in data
housingData <- housingData %>% 
  mutate(normYearBuilt = normalizeDist(housingData$GrLivArea) )
```

#### See the normalized Lot Area variable 
* You can see that the data is definitely more normal

```{r, fig.width=6, fig.height=6}
# Now see the results of the normalization
par(mfrow=c(2,1))

hist( housingData$GrLivArea, 
      main = paste('Raw', varTitle), xlab = paste('Raw', varTitle), 
      col = badCol )

hist( housingData$normYearBuilt,
      main = paste('Normalized', varTitle), xlab = paste('Normalized', varTitle),
      col = goodCol )

```


\newpage

## `2 (b)`


\newpage

## `2 (c)`



